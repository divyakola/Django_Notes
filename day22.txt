		cookies and sessions
		---------------------
Cookies:
---------
	Http is a stateless protocol, when a request is send to the server it has no idea wheather you are requesting for the first time (or) you are the same person who has visited this page thousands times before.

	This is a problem, to overcome this problem we are introducing "cookie".

	A cookie was first implemented by a programmer named "Louis Mountulli" in the year of 1994.

What is Cookie:-
----------------
	A cookie is a small piece of data,which is stored in the users browser which is sent by the server.

	They are commonly used to store user preferrences.

How to working cookie
---------------------
	The browser sends the request to the server, the server process that request and sends the response along with one (or) more cookies to the browser.

	The browser saves the cookie received from the server.


Note:
-----	
	With the help of cookie we can solve the problem of statelessness of http.


Sessions:-
----------
	We are introducing the sessions to overcome the problems in cookies.

Problems in cookies:
--------------------
	1. An attacker can modify contents of a cookie.
	2. We cannot store sensitive data.
	3. We can store limited amount of data in cookie.

How to working with sessions:
------------------------------
	When we sessions the data is not stored directly in the browser instead of it is stored in the server.

	Django creates a unique random string called session id (or) SID and associates SID with the data.

	The server then sends a cookie name sesion id containing sid as value to the browser.

	Sid generated by django is a 32 characters long random string , so it is almost impossible to guess by an attacker.

Setting up sessions:
--------------------
	In django, we are implemented sessions using middleware.

Open settings.py file middleware option is available,

	django.contrib.session.middleware.SessionMiddleware


Model Inheritances:
------------------
in django,the model inheritances can be categorized into 3-types,they are

	abstract base class inheritance
	multi-table inheritance
	proxy model inheritance

abstract base class inheritance:
---------------------------------
no table for base class,only for derived classes.

can't perform CRUD opertaions on base class.
we can perform CRUD operations on only derived classes.


syntax
------
from django.db import models
class x(models.Model):
      f_1=models.CharField(max_length=20)
      f_2=models.CharField(max_length=20)
    
      class Meta:
	    abstract=True
class y(x):
       f_3=models.CharField(max_length=20)

ex:
---
	models.py
	--------
from django.db import models

# Create your models here.
class Teacher(models.Model):
    name=models.CharField(max_length=30)
    add=models.CharField(max_length=50)
    
    class Meta:
        abstract=True

class Student(Teacher):
    email=models.EmailField()

multi-table inheritance:
------------------------
to create tables for both base class and derived class.
we can perform CRUD operations on both base and derived class

syntax:
-------
from django.db import models

# Create your models here.
class x(models.Model):
    f_1=models.CharField(max_length=20)
    f_2=models.CharField(max_length=30)

class y(x):
    f_3=models.BooleanField(default=False)
    f_4=models.BooleanField(default=False)

ex:
----
from django.db import models

# Create your models here.
class Teacher(models.Model):
    name=models.CharField(max_length=20)
    add=models.CharField(max_length=50)
    
class Student(Teacher):
    email=models.EmailField()


proxy model inheritance:
-----------------------
to create tables for both base class and derived class.

we can perform CRUD operations on both base and derived class.

we can perform CRUD operations on one table(base) will be copied to the another table(derived).

we can't create a new fields in proxy model

syntax:
--------
from django.db import models

# Create your models here.
class x(models.Model):
    f_1=models.CharField(max_length=20)
    f_2=models.CharField(max_length=30)

class y(x):
    class Meta:
	proxy=True

ex:
---
	models.py
	---------
from django.db import models

# Create your models here.
class Teacher(models.Model):
    name=models.CharField(max_length=20)
    add=models.CharField(max_length=30)
    email=models.EmailField()

class Student(Teacher):
    class Meta:
        proxy=True


ex:
---
>>> from app27.models import Teacher,Student
>>> for rec in Teacher.objects.all():
        print(rec.name,rec.address,rec.email)

siva hyd siva@gmail.com
rama pune rama@gmail.com

>>> for rec in Student.objects.all():
        print(rec.name,rec.address,rec.email)

siva hyd siva@gmail.com
rama pune rama@gmail.com



on_delete Options:
------------------
	syntax
	------
Field Name = models.modelfieldtype(ModelName,on_delete = OPERATION TYPE)

1.CASCADE
----------
When the on_delete argument is set to cascade then deleting the referenced object will have substantial effect on the referred objects. This means when the referenced object is deleted from the database then all the entries of the refered object will also be deleted from the entire database. 

ex:
---
	models.py
	---------
from django.db import models

# Create your models here.
class Teacher(models.Model):
    tname=models.CharField(max_length=30)
    tadd=models.CharField(max_length=50)
class Student(models.Model):
    sid=models.IntegerField(primary_key=True)
    sname=models.CharField(max_length=30)
    sadd=models.CharField(max_length=50)
    teacher=models.ForeignKey(Teacher,on_delete=models.CASCADE)
    

2. PROTECT
-----------
PROTECT is the direct opposite of cascade option, here if there is impact on the actual object then all instances of the data on the referenced object are not deleted. So, no deletion happens. This makes the data to be protected before delete processing on the referenced object.

ex:
---
	models.py
	---------
	
	

3. RESTRICT
-------------
The RESTRICT is very similar to the PROTECT option, it does the same job just as like the deletion option. The only difference here is when deletion is targeted on the referenced object then the ON_DELETE will raise an error called the RestrictedError. But the RESTRICT will allow deletion to happen when the referencing object and the object which is referenced object is allotted with a reference to a different common object then the deletion is allowed to takes place.
	
ex:
---
	models.py
	-----------
from django.db import models

# Create your models here.
class Teacher(models.Model):
    tname=models.CharField(max_length=30)
    tadd=models.CharField(max_length=50)
class Student(models.Model):
    sid=models.IntegerField(primary_key=True)
    sname=models.CharField(max_length=30)
    sadd=models.CharField(max_length=50)
    teacher=models.ForeignKey(Teacher,on_delete=models.RESTRICT)


4. SET_NULL

The option functions in the same way the name suggests, when a deletion happens to the referenced object then the value of the referencing object will be updated as NULL. So a NULL value will be placed for the referencing object. This is how the SET NULL will operate basically.

ex:
---
	models.py
	---------
from django.db import models

# Create your models here.
class Teacher(models.Model):
    tname=models.CharField(max_length=30,)
    tadd=models.CharField(max_length=50,)
class Student(models.Model):
    sid=models.IntegerField(primary_key=True)
    sname=models.CharField(max_length=30)
    sadd=models.CharField(max_length=50)
    teacher=models.ForeignKey(Teacher,null=True,on_delete=models.SET_NULL)


5. SET_DEFAULT
The option functions in the same way the name suggests, when a deletion happens to the referenced object then the value of the referencing object will be updated with a default value which it is allotted for, so all instances of the referencing object will be allotted with this default value. So a default value will be placed for the referencing object. This is how the SET DEFAULT will operate basically.

